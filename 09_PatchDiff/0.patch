--- labyrinth.c	2025-11-26 02:39:07.633838432 +0300
+++ labyrinth0.c	2025-11-26 02:44:32.248328029 +0300
@@ -6,117 +6,130 @@
 
 
 #define SIZE 6
-#define MATRIX(arr, i, j, size) arr[(i) * (size) + (j)]
 
 typedef struct {
 	int number;
 	char type;
 } Cell;
 
-
-void init(Cell *lab, int size) {
-	for (int i = 0; i < size; i++) {
-		for (int j = 0; j < size; j++) {
+typedef struct {
+	Cell *cells;
+	int size;
+} Maze;
+
+#define MATRIX(arr, i, j) (arr)->cells[(i) * ((arr)->size) + (j)]
+
+#define MAZE_CELL_TYPE(maze, i, j) MATRIX(maze, i, j).type
+#define MAZE_CELL_VAL(maze, i, j) MATRIX(maze, i, j).number
+
+int init(Maze *maze) {
+	for (int i = 0; i < maze->size; i++) {
+		for (int j = 0; j < maze->size; j++) {
 			if (i % 2 == 0 || j % 2 == 0) {
-				MATRIX(lab, i, j, size).type = '#';
+				MAZE_CELL_TYPE(maze, i, j) = '#';
 			} else {
-				MATRIX(lab, i, j, size).type = '.';
+				MAZE_CELL_TYPE(maze, i, j) = '.';
 			}
-			if (i == 0 || j == 0 || i == size - 1 || j == size - 1) {
-				MATRIX(lab, i, j, size).number = 1;
+			if (i == 0 || j == 0 || i == maze->size - 1 || j == maze->size - 1) {
+				MAZE_CELL_VAL(maze, i, j) = 1;
 			} else {
-				MATRIX(lab, i, j, size).number = 0;
+				MAZE_CELL_VAL(maze, i, j) = 0;
 			}
 		}
 	}
+	int count = 0;
+	for (int j = 1; j < maze->size; j += 2) {
+		MAZE_CELL_VAL(maze, 1, j) = count++;
+	}
+	return count;
 }
 
 
-void right(Cell *lab, int *counts, int line, int size) {
-	counts[MATRIX(lab, line, 1, size).number] += 1;
-	for (int i = 3; i < size; i += 2) {
+void right(Maze *maze, int *counts, int line) {
+	counts[MAZE_CELL_VAL(maze, line, 1)] += 1;
+	for (int i = 3; i < maze->size; i += 2) {
 		if (rand() % 2 == 1) {
-			MATRIX(lab, line, i - 1, size).number = 1;
-			MATRIX(lab, line - 1, i - 1, size).number = 1;
+			MAZE_CELL_VAL(maze, line, i - 1) = 1;
+			MAZE_CELL_VAL(maze, line - 1, i - 1) = 1;
 		} else {
-			if (MATRIX(lab, line, i, size).number == MATRIX(lab, line, i - 2, size).number) {
-				MATRIX(lab, line, i - 1, size).number = 1;
-				MATRIX(lab, line - 1, i - 1, size).number = 1;
+			if (MAZE_CELL_VAL(maze, line, i) == MAZE_CELL_VAL(maze, line, i - 2)) {
+				MAZE_CELL_VAL(maze, line, i - 1) = 1;
+				MAZE_CELL_VAL(maze, line - 1, i - 1) = 1;
 			} else {
-				MATRIX(lab, line, i, size).number = MATRIX(lab, line, i - 2, size).number;
-				MATRIX(lab, line, i - 1, size).number = 0;
+				MAZE_CELL_VAL(maze, line, i) = MAZE_CELL_VAL(maze, line, i - 2);
+				MAZE_CELL_VAL(maze, line, i - 1) = 0;
 			}
 		}
-		counts[MATRIX(lab, line, i, size).number] += 1;
+		counts[MAZE_CELL_VAL(maze, line, i)] += 1;
 	}
 }
 
-void last(Cell *lab, int size) {
-	for (int i = 3; i < size; i += 2) {
-		if (MATRIX(lab, size - 2, i - 2, size).number != MATRIX(lab, size - 2, i, size).number) {
-			MATRIX(lab, size - 2, i - 1, size).number = 0;
+void last(Maze *maze) {
+	for (int i = 3; i < maze->size; i += 2) {
+		if (MAZE_CELL_VAL(maze, maze->size - 2, i - 2) != MAZE_CELL_VAL(maze, maze->size - 2, i)) {
+			MAZE_CELL_VAL(maze, maze->size - 2, i - 1) = 0;
 		}
 	}
 }
 
-void down(Cell *lab, int *counts, int line, int size) {
-	for (int i = 1; i < size; i += 2) {
+void down(Maze *maze, int *counts, int line) {
+	for (int i = 1; i < maze->size; i += 2) {
 		if (rand() % 2 == 1) {
-			if (counts[MATRIX(lab, line, i, size).number] == 1) {
+			if (counts[MAZE_CELL_VAL(maze, line, i)] == 1) {
 				continue;
 			}
-			counts[MATRIX(lab, line, i, size).number] -= 1;
-			MATRIX(lab, line + 1, i, size).number = 1;
+			counts[MAZE_CELL_VAL(maze, line, i)] -= 1;
+			MAZE_CELL_VAL(maze, line + 1, i) = 1;
 		}
 	}
-	for (int i = 1; i < size - 1; i++) {
-		if (MATRIX(lab, line + 1, i, size).number == 1) {
-			MATRIX(lab, line + 1, i - 1, size).number = 1;
+	for (int i = 1; i < maze->size - 1; i++) {
+		if (MAZE_CELL_VAL(maze, line + 1, i) == 1) {
+			MAZE_CELL_VAL(maze, line + 1, i - 1) = 1;
 		}
-		if (MATRIX(lab, line, i, size).type == '#' && MATRIX(lab, line, i, size).number == 1) {
-			MATRIX(lab, line + 1, i, size).number = 1;
+		if (MAZE_CELL_TYPE(maze, line, i) == '#' && MAZE_CELL_VAL(maze, line, i) == 1) {
+			MAZE_CELL_VAL(maze, line + 1, i) = 1;
 		}
 	}
 }
 
-void next_line(Cell *lab, int *counts, int count, int line, int size) {
-	for (int i = 1; i < size - 1; i += 1) {
-		if (MATRIX(lab, line - 2, i, size).type == '#') {
-			MATRIX(lab, line, i, size).number = 0;
+void next_line(Maze *maze, int *counts, int count, int line) {
+	for (int i = 1; i < maze->size - 1; i += 1) {
+		if (MAZE_CELL_TYPE(maze, line - 2, i) == '#') {
+			MAZE_CELL_VAL(maze, line, i) = 0;
 		} else {
-			if (MATRIX(lab, line - 1, i, size).number == 1) {
-				MATRIX(lab, line, i, size).number = -1;
+			if (MAZE_CELL_VAL(maze, line - 1, i) == 1) {
+				MAZE_CELL_VAL(maze, line, i) = -1;
 			} else {
-				MATRIX(lab, line, i, size).number = MATRIX(lab, line - 2, i, size).number;
+				MAZE_CELL_VAL(maze, line, i) = MAZE_CELL_VAL(maze, line - 2, i);
 			}
 		}
 	}
 	memset(counts, 0, count * sizeof(int));
-	for (int i = 1; i < size; i += 2) {
-		if (MATRIX(lab, line, i, size).number != - 1) {
-			counts[MATRIX(lab, line, i, size).number] = 1;
+	for (int i = 1; i < maze->size; i += 2) {
+		if (MAZE_CELL_VAL(maze, line, i) != - 1) {
+			counts[MAZE_CELL_VAL(maze, line, i)] = 1;
 		}
 	}
 	int cur = 0;
-	for (int i = 1; i < size; i += 2) {
+	for (int i = 1; i < maze->size; i += 2) {
 		while (counts[cur]) {
 			cur++;
 		}
-		if (MATRIX(lab, line, i, size).number == - 1) {
+		if (MAZE_CELL_VAL(maze, line, i) == - 1) {
 			counts[cur] = 1;
-			MATRIX(lab, line, i, size).number = cur++;
+			MAZE_CELL_VAL(maze, line, i) = cur++;
 		}
 	}
 	memset(counts, 0, count * sizeof(int));
 }
 
-void print(Cell *lab, int *counts, int count, int line, int size) {
-	for (int i = 0; i < size; i++) {
-		printf("%c:%d ", MATRIX(lab, line - 2, i, size).type, MATRIX(lab, line - 2, i, size).number);
+void print(Maze *maze, int *counts, int count, int line) {
+	for (int i = 0; i < maze->size; i++) {
+		printf("%c:%d ", MAZE_CELL_TYPE(maze, line - 2, i), MAZE_CELL_VAL(maze, line - 2, i));
 	}
 	printf("\n");
-	for (int i = 0; i < size; i++) {
-		printf("%c:%d ", MATRIX(lab, line - 1, i, size).type, MATRIX(lab, line - 1, i, size).number);
+	for (int i = 0; i < maze->size; i++) {
+		printf("%c:%d ", MAZE_CELL_TYPE(maze, line - 1, i), MAZE_CELL_VAL(maze, line - 1, i));
 	}
 	printf("\n");
 	for (int i = 0; i<count; i++) {
@@ -129,35 +142,38 @@
 	// srand(time(NULL)); 
 	srand(19978); 
 	int size = SIZE * 2 + 1; 
-	Cell *lab = malloc(size * size * sizeof(Cell));
-	if (lab == NULL) {
+
+	Maze maze;
+	maze.size = size;
+	maze.cells = malloc(maze.size * maze.size * sizeof(Cell));
+	if (maze.cells == NULL) {
 		fprintf(stderr, "Error: allocation failed\n");
 		exit(1);
 	}
-	init(lab, size);
 
-	int count = 0;
-	for (int j = 1; j < size; j += 2) {
-		MATRIX(lab, 1, j, size).number = count++;
-	}
+	int count  = init(&maze);
 	int *counts = malloc(count * sizeof(int));
 	if (counts == NULL) {
 		fprintf(stderr, "Error: allocation failed\n");
-		free(lab);
+		free(maze.cells);
 		exit(1);
 	}
+
 	memset(counts, 0, count * sizeof(int));
-	right(lab, counts, 1, size);
-	down(lab, counts, 1, size);
-	for (int j = 3; j < size; j += 2) {
-		next_line(lab, counts, count, j, size);
-		right(lab, counts, j, size);
-		down(lab, counts, j, size);
-	}
-	last(lab, size);
-	for (int i = 0; i < size; i++) {
-		for (int j = 0; j < size; j++) {
-			if (MATRIX(lab, i, j, size).type == '#' && MATRIX(lab, i, j, size).number == 1) {
+	right(&maze, counts, 1);
+	down(&maze, counts, 1);
+
+	for (int j = 3; j < maze.size; j += 2) {
+		next_line(&maze, counts, count, j);
+		right(&maze, counts, j);
+		down(&maze, counts, j);
+	}
+
+	last(&maze);
+
+	for (int i = 0; i < maze.size; i++) {
+		for (int j = 0; j < maze.size; j++) {
+			if (MAZE_CELL_TYPE(&maze, i, j) == '#' && MAZE_CELL_VAL(&maze, i, j) == 1) {
 				printf("%c", '#');
 			} else {
 				printf("%c", '.');
@@ -165,6 +181,7 @@
 		}
 		printf("\n");
 	}
+
 	free(counts);
-	free(lab);
+	free(maze.cells);
 }
\ No newline at end of file
